<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: physics | Learning Three.js]]></title>
  <link href="http://learningthreejs.com/blog/categories/physics/atom.xml" rel="self"/>
  <link href="http://learningthreejs.com/"/>
  <updated>2013-03-26T17:10:21+01:00</updated>
  <id>http://learningthreejs.com/</id>
  <author>
    <name><![CDATA[Jerome Etienne]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[3D Physics With Three.js and Physijs]]></title>
    <link href="http://learningthreejs.com/blog/2012/06/05/3d-physics-with-three-js-and-physijs/"/>
    <updated>2012-06-05T12:13:00+02:00</updated>
    <id>http://learningthreejs.com/blog/2012/06/05/3d-physics-with-three-js-and-physijs</id>
    <content type="html"><![CDATA[<p>This is yet another post about physics.
This one is about
<a href="https://github.com/chandlerprall/Physijs">physijs</a>
by
<a href="https://twitter.com/#!/chandlerprall">Chandler Prall</a>.
It easily bind
<a href="https://github.com/kripken/ammo.js/">ammo.js</a>
and
<a href="http://mrdoob.github.com/three.js/">three.js</a>.
We will walk thru an example using it.
Physics is always important in 3D graphics.
It makes scenes more realistic.
Additionally, if you simple put your object into the scene, it will move nicely and realisticly.
So you spend less time tuning each moves. I am quite lazy so it matters :)
The <a href="http://www.youtube.com/watch?v=THI82Q-P8Fo">screencast</a>
presents the <a href="/data/2012-06-05-3d-physics-with-three-js-and-physijs/">demo we gonna code</a>
and various examples of what is possible with
<a href="https://github.com/kripken/ammo.js/">ammo.js</a>.</p>

<center>
    <iframe width="425" height="349" src="http://www.youtube.com/embed/THI82Q-P8Fo" frameborder="0" allowfullscreen></iframe>
</center>




<!-- more -->


<h2>What About Physics Engines ?</h2>

<p>We already did physics with three.js.
It was with <a href="https://github.com/jeromeetienne/microphysics.js">microphysics.js</a> for <a href="http://marblesoccer.com">marblesoccer</a> minigame.
It is a micro library implementing 3D physics.
We talked quite a bit about it in
<a href="http://learningthreejs.com/blog/2011/10/17/lets-make-a-3d-game-microphysics-js/">"Lets Make a 3D Game: microphysics.js"</a>
and
<a href="http://learningthreejs.com/blog/2011/11/02/lets-make-a-3d-game-helper-for-microphysics-js/">"Lets Make a 3D Game: microphysics.js, Even Easier"</a>.
It is only 500lines!
Unfortunatly, this tiny size comes limitations.</p>

<p>Today we gonna use <a href="https://github.com/chandlerprall/Physijs">physijs</a> by <a href="https://twitter.com/#!/chandlerprall">Chandler Prall</a>.
This is a nice library which make it easy to use
<a href="https://github.com/kripken/ammo.js/">ammo.js</a>
with
<a href="http://mrdoob.github.com/three.js/">three.js</a>.
ammo.js is "Direct port of the Bullet physics engine to JavaScript using
<a href="https://github.com/kripken/emscripten">Emscripten</a>.
The source code is translated directly to JavaScript, without human rewriting, so functionality should be identical to the original Bullet."</p>

<p><a href="http://bulletphysics.org/">bullet</a> is a full-blown physics engine well-known in the 3D community.
It can do a lot as you can see in its <a href="http://bulletphysics.com/Bullet/BulletFull/">docs</a>.
<a href="https://github.com/kripken/ammo.js/">ammo.js</a>
supports all the features you can expect from a mature 3D physics engine.
Charles J. Cliffe, aka <a href="https://twitter.com/#!/ccliffe">@ccliffe</a>,
did several demos using ammo.js.
This one is a <a href="http://cjcliffe.github.com/CubicVR.js/cubicvr/samples/physics/physics_heightfield.html">heighfield</a>
And look at this <a href="http://cjcliffe.github.com/CubicVR.js/cubicvr/samples/vehicle_physics_demo/stunt_track1.html">stunt track</a>!
Both are on top of <a href="http://www.cubicvr.org/">cubicvr</a>, <a href="https://twitter.com/#!/ccliffe">@ccliffe</a> own library.</p>

<p><a href="https://github.com/chandlerprall/Physijs">physijs</a> has been written with performance in mind.
<a href="https://github.com/kripken/ammo.js/">ammo.js</a> is running in a
<a href="https://developer.mozilla.org/En/Using_web_workers">webworker</a>.
So it most likely run on a second CPU. This is twice more cpu power for your javascript!
Coordinates are exchanged with
<a href="http://updates.html5rocks.com/2011/12/Transferable-Objects-Lightning-Fast">transferable objects</a>
when available.
Transferable objects is a special type of object which can be transfered between the main thread and the worker <strong>without copying</strong>
the data. Thus no matter how large the data are, it will be very low latency.</p>

<h2>Lets Get Started</h2>

<p>The code of today is a copy of the
<a href="http://chandlerprall.github.com/Physijs/examples/collisions.html">collision example</a>
from
<a href="http://chandlerprall.github.com/Physijs/">physijs</a>
using it thru tQuery API.
It may usefull to reimplement the same thing, just to be sure they both perform the same way. :)
<a href="/data/2012-06-05-3d-physics-with-three-js-and-physijs/">Try it out</a>.
So we got object falling on the ground and slightly bouncing on it. Let's do just that.</p>

<center>
    <iframe width="100%" height="420" src="http://learningthreejs.com/data/2012-06-05-3d-physics-with-three-js-and-physijs/" frameborder="0" allowfullscreen webkitallowfullscreen mozallowfullscreen></iframe>
</center>


<p>First a classic. We create a tQuery.World. So you immediatly got
a scene, a renderer, camera and its controls. All that already
setup according to reasonable default.
 <code>.boilerplate()</code> adds
the <a href="http://learningthreejs.com/blog/2011/12/20/boilerplate-for-three-js/">"three.js boilerplate"</a>
we did last year. We disable the camera controls as it will stay still in this scene.
Then we <code>.start()</code> to launch the render loop.</p>

<p>```</p>

<pre><code>var world   = tQuery.createWorld().boilerplate({cameraControls: false}).start();
</code></pre>

<p>```</p>

<p>Now we setup the camera to be a bit far from the scene center. Thus
we got room to display larger objects</p>

<p>```</p>

<pre><code>world.tCamera().position.set( 70, 40, 70 );
world.tCamera().lookAt( world.tScene().position );
</code></pre>

<p>```</p>

<p>Now we need to tell the renderer that shadow has to be casted. This is done by the simple lines below.
We saw the details in <a href="http://learningthreejs.com/blog/2012/01/20/casting-shadows/">"Casting Shadows"</a> post.</p>

<p>```</p>

<pre><code>world.tRenderer().shadowMapEnabled  = true;
world.tRenderer().shadowMapSoft     = true;
world.tRenderer().setClearColorHex( 0xffffff, 1 );
</code></pre>

<p>```</p>

<p>Now we enable the physics into the world.
this is important. From now on, all the physics-enabled object
of this world will move according to realistic physics rules.</p>

<p>```</p>

<pre><code>world.enablePhysics();
</code></pre>

<p>```</p>

<h2>Enlight your world</h2>

<p>Here we setup the lights. For simplicity sake, we will use only one directional light.
First we tune the position and color to fit our tastes. Dont be shy, play with those parameters to get a feel of it.
Then we tune shadow parameters.
Those can be tricky to tune.
You can find more details in <a href="http://learningthreejs.com/blog/2012/01/20/casting-shadows/">"Casting Shadow"</a> post.
It helps if you make the shaddow camera visible. You can do so with <code>.shadowCameraVisible(true)</code>.</p>

<p>```</p>

<pre><code>tQuery.createDirectionalLight().addTo(world)
    .position(20, 40, -15).color(0xffffff)
    .castShadow(true).shadowMap(512*2,512*2)
    .shadowCamera(60, -60, 60, -60, 20, 200)
    .shadowDarkness(0.7).shadowBias(.002)
</code></pre>

<p>```</p>

<h2>Let's create a ground to stand on</h2>

<p>First we create the texture for our ground. We use <code>rocks.jpg</code> to have like a rock
effect. We use <code>.RepeatWrapping</code> to repeat the texture on the faces and get a
proper scale.</p>

<p>```</p>

<pre><code>var texture = THREE.ImageUtils.loadTexture( "images/rocks.jpg" );
texture.wrapS   = texture.wrapT = THREE.RepeatWrapping;
texture.repeat.set( 3, 3 );
</code></pre>

<p>```</p>

<p>In fact, the ground is only a cube which is wide and flat, a bit like
the <a href="http://en.wikipedia.org/wiki/Flat_Earth">old-vision of earth</a> :)
It is usual now, we setup the position, material and shadow.</p>

<p>```</p>

<pre><code>var ground  = tQuery.createCube(100, 1, 100).addTo(world)
    .position(0, -10, 0)
    .setLambertMaterial().map(texture).back()
    .receiveShadow(true)
</code></pre>

<p>```</p>

<p>Now we just have to setup the physics for the ground. This is done
by <code>.enablePhysics()</code>. The <code>mass</code> parameter define the mass
of the object in the physics.
By default, it is automatically computed depending on the volume of the object.
Here zeroing the mass is a special case, which say
"the mass is infinite, dont move, ever" :)</p>

<p>```</p>

<pre><code>ground.enablePhysics({
    mass    : 0
});
</code></pre>

<p>```</p>

<h2>Spawning object in a 3D world</h2>

<p>Spawning is always a delicate matter in our world.
But first let's load the texture for the spawned objects.
It is done outside of the loop thus it get reused. Aka it is sent
only once to the GPU for all the objects. This is an important
point from performance point of view. Last year,
<a href="http://learningthreejs.com/blog/2011/09/16/performance-caching-material/">"Performance: Caching Material"</a>
post was about this very topic.</p>

<p>```</p>

<pre><code>var cTexture    = THREE.ImageUtils.loadTexture( "images/plywood.jpg" );
</code></pre>

<p>```</p>

<p>Now we declare <code>spawnObject()</code> which gonna take care of spawning one object.
So we create a cube, setup its position, rotation and material. This is all good. Oh dont
forget to use <code>.castShadow()</code> as got <a href="http://en.wikipedia.org/wiki/Shadow_mapping">shadow mapping</a> going on :)</p>

<p>```</p>

<pre><code>var spawnObject = function(){
    var object  = tQuery.createCube(4,4,4).addTo(world)
        .rotation(Math.random()*Math.PI*2, Math.random()*Math.PI*2, Math.random()*Math.PI*2)
        .position(Math.random()*15-7.5, 25, Math.random()*15-7.5)
        .setLambertMaterial().map(cTexture).back()
        .castShadow(true)
</code></pre>

<p>```</p>

<p>Here we enable the physics on this object. So the world will handle all its move from now on.
It will object to physics laws according to the parameters you setup.
<a href="http://en.wikipedia.org/wiki/Friction">friction</a> is the force resisting when 2 objects slides against each other.
<a href="http://en.wikipedia.org/wiki/Coefficient_of_restitution">resititution</a> is how bouncy the object is.
For scientific definition, go read a book :)</p>

<p>```</p>

<pre><code>    object.enablePhysics({
        friction    : 0.4,
        restitution : 0.6
    });
</code></pre>

<p>```</p>

<p>Now we gonna play with the 'collision' event. Physijs is able to notify
you when an object collide with another. Just use <code>.addEventListener()</code> on 'collision'.
Here we gonna change the color of the object depending on the number of collisions
they got.</p>

<p>```</p>

<pre><code>    var nCollisions = 0;
    object.physics().addEventListener('collision', function(){
        var colliColors = [0xcc8855, 0xbb9955, 0xaaaa55, 0x99bb55, 0x88cc55, 0x77dd55];
        if( ++nCollisions &lt; colliColors.length ){
            var color   = colliColors[nCollisions];
            object.get(0).material.color.setHex( color );
        }
    })
}
</code></pre>

<p>```</p>

<p>Now we simply use <a href="https://developer.mozilla.org/en/DOM/window.setInterval"><code>setInterval()</code></a> to
spawn an object every seconds.</p>

<p>```</p>

<pre><code>setInterval(spawnObject, 1000);
</code></pre>

<p>```</p>

<p>And we are DONE! We got a realistic physics in our 3D world! not bad hey :)</p>

<h2>Conclusion</h2>

<p>So, thanks to <a href="https://github.com/chandlerprall/Physijs">physijs</a>,
it is now possible to get full blown realistic physics
using
<a href="https://github.com/mrdoob/three.js/">three.js</a>
and
<a href="https://github.com/jeromeetienne/tquery">tQuery</a>.
It is a simple way to make scene more realistic. It is nice to experiment with.
I will do more on this very soon!</p>

<p>Thanks all folks! have fun :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lets Make a 3D Game: microphysics.js, even easier]]></title>
    <link href="http://learningthreejs.com/blog/2011/11/02/lets-make-a-3d-game-helper-for-microphysics-js/"/>
    <updated>2011-11-02T18:16:00+01:00</updated>
    <id>http://learningthreejs.com/blog/2011/11/02/lets-make-a-3d-game-helper-for-microphysics-js</id>
    <content type="html"><![CDATA[<p>This post is part of the <a href="/blog/categories/tutorial3dgame/">"Lets make a 3D game"</a> series.
It is a follow up from the previous article on <a href="/blog/2011/10/17/lets-make-a-3d-game-microphysics-js/">microphysics.js</a>.
It will describe how to easily include <strong>microphysics.js</strong> in your three.js games.
<a href="https://raw.github.com/jeromeetienne/microphysics.js/master/THREEx.microphysics.js">THREEx.microphysics.js</a> is a THREEx wrapper for microphysics.js.
It helps binding <a href="https://github.com/mrdoob/three.js/">three.js</a> objects to <a href="/blog/2011/10/17/lets-make-a-3d-game-microphysics-js/">microphysics.js</a>.
The API is chained for convenience.</p>

<h2>Let's get started</h2>

<p>So lets see how to use it.
First step, you download it
<a href="https://raw.github.com/jeromeetienne/microphysics.js/master/THREEx.microphysics.js">here</a>.
Then include it in your own code with this line.</p>

<p>```html</p>

<pre><code>&lt;script src="THREEx.microphysics.js"&gt;&lt;/script&gt;
</code></pre>

<p>```</p>

<!-- more -->


<h2>Initialisation</h2>

<p>You instanciate the physics engine, like that.</p>

<p>```javascript</p>

<pre><code>var microphysics = new THREEx.Microphysics(opts);
</code></pre>

<p>```</p>

<p> <code>opts</code> is optional.
 <code>opts.timeStep</code> controls the frequency of the world update.
The smaller it is the more accurate is the physics but the longer it is to compute.
It defaults to <code>1/60</code>. Once instanciated, you start it.</p>

<p>```javascript</p>

<pre><code>microphysics.start();
</code></pre>

<p>```</p>

<h2>Binding THREE.Mesh</h2>

<p>Of course we need to add some mesh in the world. After this line, the <code>mesh</code>
is bound to microphysics.js, so its position is driven by the physics.</p>

<p>```javascript</p>

<pre><code>microphysics.bindMesh(mesh, opts);
</code></pre>

<p>```</p>

<p> <code>mesh.position</code> is honored.
If you need to unbind a <code>mesh</code>, just do</p>

<p>```javascript</p>

<pre><code>microphysics.unbindMesh(mesh);
</code></pre>

<p>```</p>

<p>At the time of this writing, microphysics.js support only moving sphere and static
boxes, so geometry may only be <code>THREE.SphereGeometry</code> or <code>THREE.CubeGeometry</code>.
If your mesh got another geometry, use <code>opts.geometry</code> to say how you wish the mesh
to be handled.</p>

<p>```javascript</p>

<pre><code>microphysics.bindMesh(mesh, {
     geometry   : new THREE.CubeGeometry(200,200,200);
});
</code></pre>

<p>```</p>

<p>It is also possible to overwrite <code>Mesh.position</code> with <code>opts.position</code>, or
to send options directly to microphysics.js with <code>opts.physics</code>.</p>

<p>```javascript</p>

<pre><code>microphysics.bindMesh(mesh, {
    // to overwrite the Mesh.position
    position    : { x : 1, y : 1, z : 2 },
    // to pass options directly to microphysics.js
    physics     : { restitution : 0.98 }
});
</code></pre>

<p>```</p>

<h2>Updating the physics</h2>

<p>In your render loop, just add this line. It will first update the physics world and
then move accordingly any <code>THREE.Mesh</code> you bound.</p>

<p>```javascript</p>

<pre><code>microphysics.update();  
</code></pre>

<p>```</p>

<h2>Needs a Direct Access ?</h2>

<p>If you need to have direct access to microphysics.js, uses
 <code>microphysics.body(mesh)</code> to get the <code>vphy.Body</code> bound to <code>mesh</code>.
To access <code>vphy.World</code>, just use <code>microphysics.word()</code>.</p>

<h2>Conclusion</h2>

<p>In the previous article on <a href="/blog/2011/10/17/lets-make-a-3d-game-microphysics-js/">microphysics.js</a>,
we learned how to use microphysics.js directly. This article makes it really easy to include
in your <a href="https://github.com/mrdoob/three.js/">three.js</a> demo/game.
It is so nice that it is what is used in the
<a href="http://jeromeetienne.github.com/microphysics.js/playground/">playground</a>.
That's all for today folks. Have fun :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lets Make a 3D Game: microphysics.js]]></title>
    <link href="http://learningthreejs.com/blog/2011/10/17/lets-make-a-3d-game-microphysics-js/"/>
    <updated>2011-10-17T12:36:00+02:00</updated>
    <id>http://learningthreejs.com/blog/2011/10/17/lets-make-a-3d-game-microphysics-js</id>
    <content type="html"><![CDATA[<p>This post is part of the <a href="/blog/categories/tutorial3dgame/">"Lets make a 3D game"</a> series.
3D and physics simulation always go well together
<a href="http://www.youtube.com/watch?v=Rd7TyU9RdQk">even</a>
<a href="http://www.youtube.com/watch?v=o_xr8Htj9GI">more</a>
<a href="http://www.youtube.com/watch?v=Xfrzi-yVcsM">so</a>
<a href="http://www.youtube.com/watch?v=uvCbc8vFUMo">with</a>
<a href="http://www.youtube.com/watch?v=7lBUBBW_sF0">marble</a>
<a href="http://www.youtube.com/watch?v=c7npJ3E-ydA">games</a>.
One is required for <a href="http://marblesoccer.com">marblesoccer</a> but i wasnt
convinced by current 3d physics engines. I explain why at the end.
Fortunatly, <a href="http://twitter.com/#!/pyalot">@pyalot</a> from <a href="http://codeflow.org/">codeflow.org</a>
has been kind enough to write one taylor-made for us: <strong>microphysics.js</strong>!!</p>

<p>It is bite-sized, elegant and efficient.
Less than 500 lines at the moment!!
It is small engouh to be understood, important feature for a tutorial blog.
It is a work in progress tho.
We aren't aware of any bugs.
New features will be added and the API is expected to move.
Currently it implements moving spheres and static boxes (or <a href="http://en.wikipedia.org/wiki/Axis-aligned_bounding_box">AABB</a> as we like to say).
This is all we need for <a href="http://marblesoccer.com">marblesoccer</a>, the good thing about tailor-made.
<em>We are in business!!!</em></p>

<p>Below is a screencast of me doing a short introduction of the
<a href="http://jeromeetienne.github.com/microphysics.js/playground/">playground</a>.
This just a page for you to experiment with microphysics.js.</p>

<center>
    <iframe width="425" height="349" src="http://www.youtube.com/embed/DI5PV2_sLoM" frameborder="0" allowfullscreen></iframe>
</center>


<h2>Let's get started</h2>

<p>So lets see how to use it.
First step, you download it <a href="https://raw.github.com/jeromeetienne/microphysics.js/master/codeflow/physics.js">here</a>.
Then include it in your own code with this line.</p>

<p>```html</p>

<pre><code>&lt;script src="physics.js"&gt;&lt;/script&gt;
</code></pre>

<p>```</p>

<!-- more -->


<h2>Let's Create a World</h2>

<p><img class="right" src="/data/lets-make-a-3d-game-microphysics-js/images/galactus.png"></p>

<p>Quite a title hey ?
Dont you feel like <a href="http://en.wikipedia.org/wiki/Galactus">galactus</a> when you say it ?
First you instanciate the physics <code>world</code> like this.</p>

<p>```javascript</p>

<pre><code>var world = new vphy.World()
</code></pre>

<p>```</p>

<p>Now you start it. Dont forget to give it the date as you see it.</p>

<p>```javascript</p>

<pre><code>world.start(Date.now()/1000);
</code></pre>

<p>```</p>

<p>The <code>world</code> is now fully initialized.
You just have to periodically update it in your game/render loop.</p>

<p>```javascript</p>

<pre><code>var timeStep    = 1/180;
world.step(timeStep, Date.now()/1000);
</code></pre>

<p>```</p>

<p>The <code>timeStep</code> parameter is the precision of the physics engine, expressed in seconds.
Quite a subtle tradeoff.
The smaller it is, the more accurate is the physics, but the slower it is to compute.
Up to you to find the balance that fit your needs.</p>

<h2>Let's Add Bodies</h2>

<p><img class="left" src="/data/lets-make-a-3d-game-microphysics-js/images/The_shining_heres_johnny.jpg"></p>

<p>Don't worry, this is not about killing people and dispose of their dead bodies :)
In physics, A <a href="http://en.wikipedia.org/wiki/Rigid_body">body</a> is a solid object that you put in your world.
microphysics bodies can be spheres or static boxes.
Lets start right away by creating a sphere.</p>

<p>```javascript</p>

<pre><code>var sphere  = new vphy.Sphere({
    x : 10,
    y : 10,
    z : 10,
    restitution : 0.6,
    radius : 5,
});
</code></pre>

<p>```</p>

<p>This will position it at <code>(10,10,10)</code> in the world.
<a href="http://en.wikipedia.org/wiki/Coefficient_of_restitution">restitution</a> will determine how
bouncy is this during a collision.
A bouncing ball restitutes a lot.
A falling eggs restitutes less :)
This declaration seems quite verbose at first.
Don't worry those parameters got sensible defaults, no need to specify them all.</p>

<p>Now lets add it to our world</p>

<p>```javascript</p>

<pre><code>world.add(sphere);
</code></pre>

<p>```</p>

<p>If you need to remove it, just do <code>world.remove(sphere)</code>. Not too hard hey ?
Now lets create a static box.
Boxes are called <em>AABB</em>.
It stands for <a href="http://en.wikipedia.org/wiki/Axis-aligned_bounding_box">Axis-aligned bounding box</a>.
It is graphic jarguon for the smallest box containing your object.
 <code>vphy.Sphere</code>and <code>vphy.AABB</code> both derived from <code>vphy.Body</code>.
 <code>x, y, z, resitution</code> are <code>vphy.Body</code> parameters, common to both.
So we wont review them again.</p>

<p>```javascript</p>

<pre><code>var body = new vphy.AABB({
    width : 1,
    height: 1,
    depth : 1
});
</code></pre>

<p>```</p>

<p> <code>width</code>, <code>height</code> and <code>depth</code> gives the dimensions of the box.
After <code>world.step()</code>, you can read the new position of each body. Quite usefull
to push back the resulting physics in your 3D scene :)</p>

<p>```javascript</p>

<pre><code>var pos = body.getPosition();   // x = pos[0], y = pos[1], z = pos[2]
</code></pre>

<p>```</p>

<p>Ok, so we got a <code>world</code> with solid objects in it, all bound to <a href="http://en.wikipedia.org/wiki/Physical_law">physical law</a>.
Now what about moving them ?</p>

<h2>Let's move our Bodies</h2>

<p><img class="right" src="/data/lets-make-a-3d-game-microphysics-js/images/aerobic-small.jpg"></p>

<p>Lets make our sphere moves.
The bodies you added to the world will move according to the <a href="http://en.wikipedia.org/wiki/Force">forces</a> applied on them.
All that according to
<a href="http://en.wikipedia.org/wiki/Newton%27s_laws_of_motion">laws of motion</a>
from <a href="http://en.wikipedia.org/wiki/Isaac_Newton">Newton</a>.
He discovered that by receiving an <a href="http://en.wikipedia.org/wiki/Isaac_Newton#Apple_analogy">apple on the head</a>,
creativity can take strange paths sometime :)</p>

<p>Ok let's add <a href="http://en.wikipedia.org/wiki/Gravity_of_Earth">gravity</a>, the force which moved this falling apple.
This force is applied along a given direction to all our objects.
The library already contains an helper just for that. Simply do</p>

<p>```javascript</p>

<pre><code>world.add(new vphy.LinearAccelerator({
    x   :  0, 
    y   : -9.8,
    z   :  0
}));
</code></pre>

<p>```</p>

<p>Quite easy, no? Now lets see a custom accelerator, for example a player moving
according to the keyboard. The player will be a <code>vphy.Sphere</code> and we will
reuse the <a href="http://learningthreejs.com/data/THREEx/THREEx.KeyboardState.js">keyboard helper</a> we
did in this <a href="http://learningthreejs.com/blog/2011/09/12/lets-Make-a-3D-game-keyboard/">post</a>.</p>

<p>```javascript</p>

<pre><code>var player  = new vphy.Sphere({ radius : 20 });
world.add({
    type: vphy.types.ACCELERATOR,   // let the lib know it is an accelerator
    perform: function(bodies){      // bodies is the array of all vphy.Body
        if( keyboard.pressed('right') ) player.accelerate(1,0,0);
        if( keyboard.pressed('left') )  player.accelerate(-1,0,0);
        if( keyboard.pressed('up') )    player.accelerate(0,0,1);
        if( keyboard.pressed('down') )  player.accelerate(0,0,-1);
    }
});
</code></pre>

<p>```</p>

<p> <code>.perform()</code> will be called at every world step.
It accesses <code>player</code> via
<a href="https://developer.mozilla.org/en/JavaScript/Guide/Closures">closure</a>
, read current keyboard state and accelerate in the proper direction.</p>

<h2>Motivation</h2>

<p>The need for 3D physics is clear for <a href="http://marblesoccer.com">marblesoccer</a>.
Marble in physics are fun, generic and instinctive for the player.
Ok so how to get a 3D physics engine ?</p>

<ul>
<li><strong>Do it yourself ? </strong>
Well no, it is hard, long and im lazy :)</li>
<li><strong>Use an existing one ? </strong>
i tried some and left unimpressed. All those are new experimental stuff.
Documentation is inexistant.
They are issued from existing libraries in other languages and convert them to js, sometime multiple conversions in a row.
I experienced major bugs when i tried. Were those bugs ? Was it me misusing it ?
Quite possible as the doc is inexistant.
All in all, i didnt feel it would be a reliable dependancy for our game.</li>
<li><strong>Used a 2D one, like Box2D ? </strong>
Box2D is kind of special.
<a href="http://blog.sethladd.com/">Seth Ladd</a> recently did
<a href="http://blog.sethladd.com/2011/09/box2d-collision-damage-for-javascript.html">a</a>
<a href="http://blog.sethladd.com/2011/09/box2d-impulse-and-javascript.html">lot</a>
<a href="http://blog.sethladd.com/2011/09/box2d-with-complex-and-concave-objects.html">of</a>
<a href="http://blog.sethladd.com/2011/09/box2d-and-polygons-for-javascript.html">good</a>
<a href="http://blog.sethladd.com/2011/09/box2d-web-workers-better-performance.html">things</a>
to explain box2D. Ok, box2D is a converted one but it is of very good quality.
So why not using box2D ?
Well because it is 2D and we do 3D.
Quite an insight, hey :)
It would be such a tough limitation.
This webgl + box2D strategy can produce excelent results tho, like this
<a href="http://game.2x.io/">game demo</a> from <a href="http://twitter.com/#!/einaros">@einaros</a>.
Take a close look at the physics when object move, it is amazingly
realistic and it is all box2D.</li>
<li><strong>Ask somebody else to do it ? </strong>
We got a <em>winner!</em> <a href="http://twitter.com/#!/pyalot">@pyalot</a> from <a href="http://codeflow.org/">codeflow.org</a></li>
</ul>


<h2>Credits</h2>

<p>All images are from <a href="http://en.wikipedia.org">wikipedia</a>. All hard work is from <a href="http://twitter.com/#!/pyalot">@pyalot</a></p>

<h2>Conclusion</h2>

<p>This is the first post about physics.
It presented microphysics.js API.
Thus you can start playing with it immediatly.
More posts will come shortly.
At least, one about performance and another one on how to easily bind microphysics to your three.js game.
That's all folks.
Have fun with microphysics.js :)</p>
]]></content>
  </entry>
  
</feed>
